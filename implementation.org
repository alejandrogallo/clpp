:PROPERTIES:
:header-args:lisp: :results none :eval no
:END:
#+title: CLPP: A simple common-lisp based pre-processor
#+author: Alejandro Gallo

* Introduction

** Goals

This is the code base of a simple yet powerful
preprocessor based in the common-lisp programming language.

The goals of this project are:

- simple :: the main code should be deployed in one single
  file that is able to *run in any commonly used =CL= implementation*
  without requiring any dependency.
  This ensures that HPC clusters can use code using =CLPP=
  as a preprocessor as long as they are able to compile a =CL=
  interpreter such as =ECL=.
- lisp-based :: the macros and the language should be common lisp,
  and the macro writer should know common lisp, and only common lisp.
  We refrain from developing yet another macro language.
- configurable :: The behaviour of the preprocessor should be configurable
  in a per-project way.
- raw :: The project should not be opinionated in what respects to
  how people should embed the code in their projects and/or
  which syntax to use. It should however provide a growing list
  of examples of how to employ it.
- documentation :: The project should be well-documented and explained.
  This document represents the implementation of the code,
  and is therefore written in a literate programming style.

#+begin_comment
TODO: Think about putting this or not

Some great projects targeting some of these points but not all
are for instance

- [[https://github.com/eudoxia0/cmacro][cmacro]] ::
  The macro system is quite similar to rust syntax macros.
  - However the user has to learn the syntax of the library which
    feels quite limiting in comparison to =defmacro=.
  - Depends on several libraries.
  - Implements own parser.
- [[https://github.com/kiselgra/c-mera][c-mera]] ::
  Source-to-source translation engine.
  - Opinionated about the choice of operators to use.
  - It should be possible to use =c-mera= inside of =CLPP=.
  - c-like languages based.
#+end_comment

** Philosophy

- Use as much as possible from the common-lisp system,
  this includes the code reader and the code formatter.
- Give the user the tools to write syntax to document
  for the users of the macros.
  Provide tools and ideas, but rather than provide
  support for any programming language or system,
  which is hard to maintain and needs domain specific
  knowledge, people should write small macros to do this
  job. Therefore, most users are required to know their
  way around common lisp.

CLPP works by translating s-expressions into strings,
like any other source to source translation engine.
The rules that CLPP uses, however, as especially simple
so that one can have an easy mental map of what is coming
out after the expansion.

Any s-expression is converted to a string depending on
their type, and there the only types
pre-defined in =CLPP= are

- function-macros
- symbol-macros

#+begin_todo
Think about to give command like stuff
or let the users do it
#+end_todo

* Utilities
:PROPERTIES:
:header-args:lisp+: :noweb-ref utilities
:END:

This an implementation of a dynamic =let= for =setf=-able constructs.
#+begin_src lisp
(defmacro letf (places &rest body)
  (let ((result-v (gensym "RESULT"))
        (old-v (gensym "OLD-BINDINGS")))
    `(let ((,result-v)
           (,old-v ',(loop for p in places
                           collect `(,(car p)
                                     ,(eval (car p))))))

     ,@(loop for p in places
           collect `(setf ,(car p) ,(cadr p)))
     (setq ,result-v (progn ,@body))
     (loop for p in ,old-v
           do (eval `(setf ,(car p) ,(cadr p))))
     ,result-v)))
#+end_src

Paul Graham's =symb= function
#+begin_src lisp
(defun symb (&rest args)
  (intern (format nil "狺磲疸狎＇簌礅镬钺礤狎珞┅┅＋孱溥篁序镬镧盒蚁信以膳雍鸿遽溴颦狎珞红轶皤侯秣邂蝈痱镬镧号文＋忮玳钸篁扉箴ㄤ彐疳汶徵恒祓ê躞恒飑ㄩ瞽疳汶徵恒祓皓＋孱溥篁轴蜷徕戾盒蚁信以膳雍鸿遽溴颦狎珞红轶皤侯秣邂蝈鲠蜷徕戾号文＋忮玳钸篁扉箴ㄤ彐鲠痱弩弪鲥汜箦⑿蝈箦蝣汜箦镦翳簌礅镬蝈徜ㄤ彐鲠骢钽糸镱磲泸矬犰轶舄铋飑ㄤ彐鲠簌礅镬磲泸矬犰轶舄铋飑＋孱溥篁赠疱歪泸矬盒蚁信以膳雍鸿遽溴颦狎珞红轶皤侯秣邂蝈磲泸矬号文＋忮玳钸篁扉箴ㄤ彐躅汜颦轶狒镯ㄡ麸ㄣ狎┅ㄤ彐豉疱汜颦轶狒镯īЖ筢糸箧殄汜颦轶狒镯皓ㄤ彐躅珏舡骢钽糸镱磲泸钺礤ㄧ弭骢钽糸镱磲泸矬犰轶舄钺礤┅ㄤ彐躅骢钽糸镱磲泸锃ㄥ痱ㄧ弭骢钽糸镱磲泸ㄣ狎屮痱┅ㄤ彐豉疱骢钽糸镱磲泸īЖ犷扉篝汜颦轶狒镯筢糸箧殄骢钽糸镱磲泸锃皓┅ㄤ彐躅珏舡簌礅镬磲泸钺礤ㄧ弭簌礅镬磲泸矬犰轶舄钺礤┅ㄤ彐躅簌礅镬磲泸锃ㄥ痱ㄧ弭簌礅镬磲泸屮痱┅ㄤ彐豉疱簌礅镬磲泸īЖ犷狒镯筢糸箧殄簌礅镬磲泸锃皓┅ㄤ彐躅篝蜷铉痱彐轼痱彐轼篝颟ㄥ篝蜷铉冀痱彐轼篝颟戾铉翳痱彐轼┅ㄤ彐豉疱痱彐轼邃怡痱彐轼戾è钺礤ㄧ孱簌愆┅ㄥ鲠啜溴骢钺礤篝颟篝蜷铉痱彐轼痱彐轼ㄦ矧磲铋幄篝颟┅啜筢糸箧殄钺礤┅ㄤ彐豉疱痱彐轼邃泔眄犷痱彐轼啜犷扉篝汜颦轶狒镯筢糸箧殄痱彐轼弪皓┅ㄤ彐躅屮疳钿磲泸ㄥ痱脲蝈沲蝮轹濠ㄦ戾è屮疳钿弪ㄥㄥ疳钿磲泸候邈躜箝鲥蝈沲蝮轹濠┅ㄥ豉疱汜箦屮痱ㄦ躅泗轱瞽磲泸戾舄è钺礤ㄣ狎屮痱┅ㄡ蜱磲疸狎＇屮疳钿弪ㄣ潋屮痱┅ㄦㄧ弭骢钽糸镱磲泸钺礤┅铄鳝屮痱ㄡ痧禊狎珞┅ㄩ蝈沲蝮轹ㄥ疳钿弪铄鳝屮痱铄鳝屮痱┅簌礅镬磲泸戾舄è铄鳝钺礤ㄧ弭簌礅镬磲泸屮痱┅铄鳝钺礤┅扉篝磲疸狎＇屮疳钿弪屮痱┅屮痱┅┅＋孱溥篁涅钺黹忾钿弪＋忮玳钸篁扉箴ㄤ彐磲泸骢钽糸镱磲泸锃犰轶舡疳轵ㄡ扉篝脲狎珞扉篝矧骢瞟啜扉篝Ж珏翩犰轶К脲ㄥ豉疱汜箦扉篝矧骢ㄦ躅泗轱扉篝矧骢瞟扉篝啜灬礅溽狎珞扉篝矧骢瞟┅┅ㄤ彐磲泸簌礅镬磲泸锃犰轶舡疳轵ㄡ扉篝脲螬啜扉篝Ж珏翩犰轶К脲К螬ㄤ彐磲泸戾翥镱篝蝓泗蝈沲蝮轹疳轵泔铙趄蹉麸犰轶忾钿轭珞蝈篝怙澌戾è戾翩狎珞祜镳骘轭忾钿轭珞泔祆邈ㄥ鲠啜疳轵泔铙趄蹉麸犰轶棱┅┅啜戾翩ì漓弭姝狎珞ㄥ疳钿磲泸痱镧棱镤候邈躜箝鲥蝈沲蝮轹濠┅ㄤ彐磲泸沆痧磲泸镬弭ㄢ轭溟铉蝈篝怙澌啜戾翥镱篝蝓泗铋骢钽糸镱磲泸锃犰轶舡疳轵骢钽糸镱磲泸矬犰轶舄忾钿轭珞棱镤┅ㄤ彐磲泸沆痧簌礅镬磲泸镬弭ㄢ轭溟铉蝈篝怙澌啜戾翥镱篝蝓泗铋簌礅镬磲泸锃犰轶舡疳轵簌礅镬磲泸矬犰轶舄忾钿轭珞棱镤┅＋孱溥篁盒蚁信以膳雍鸿遽溴颦狎珞红轶皤侯秣邂蝈戾舡忾钿弪号文序彐轼弩盒蚁信以膳雍鸿遽溴颦狎珞红轶皤侯秣邂蝈痱彐轼弩号文歪轭栳钿戾蝮＋忮玳钸篁扉箴ㄤ彐鲠痱彐轼犰轶舄Жá：灬礅溽ㄩ矬痱彐轼ㄦ矧磲矬狺Β蝈徜骘蝽轶痱彐轼┅┅áｌ轶鸷灬礅溽ㄩ矬痱彐轼戾è痱弩弪鲥汜箦铋飑ㄥ鲠蝈徜骘蝽轶痱彐轼┅┅áｃ孩灬礅溽ㄩ矬痱彐轼戾è骘蝽蝈徜骘蝽轶痱彐轼┅í痱弩弪鲥汜箦舂ㄦ矧磲矬狺撖"
                         (mapcar #'symbol-name form)))))))


(defmacro maybe-run-prefix (is os c)
  `(cond
     ,@(loop for pl in *prefix-alist*
             collect
             `((check-prefix ,is ,c ,(car pl))
               (when ,os
                 (funcall ,(cdr pl) ,is ,os ,(car pl)))))
     (t (when o (princ c o)))))


(defun check-prefix (s init prefix)
  "Check and consume prefix if it matches.
  If it does not match, it unreads whatever has been read."
  (loop for ref in (coerce prefix 'list)
        with read-chars = nil
        with current = init
        with i = 0
        do (incf i)
        if (char= ref current)
          append (when (/= i (length prefix))
                   (setf current (read-char s))
                   (push current read-chars))
        else
          do (dolist (c read-chars)
               (unread-char c s))
          and return nil))


(defun read-form (s prefix)
  (if *preserve-case*
    (let ((*readtable* (copy-readtable *readtable*)))
      (setf (readtable-case *readtable*) :preserve)
      (read s))
    (read s)))
#+end_src

** Include

#+begin_src lisp

(defun include-stream (s &optional (o *standard-output*))
  (let ((eof 'the-end))
    (loop
      with c = nil
      do (setf c (read-char s nil eof))
      if (eq c eof) return nil
      else do (maybe-run-prefix s o c))))

(defun include (filepath)
  (with-open-file (s filepath)
    (include-stream s nil)))

#+end_src

* Library

#+begin_src lisp :tangle clpp.lisp :noweb yes :eval yes :noweb-ref lisp-script
;; vim:ft=lisp
<<prolog>>

<<utilities>>

<<variables>>

<<macros>>

<<let-binders>>

<<prefixes>>

<<cli>>

#+end_src

* CLI
:PROPERTIES:
:header-args:lisp+: :noweb-ref cli
:END:

** ecl

#+begin_src shell :noweb yes :tangle clpp :shebang "#!/usr/bin/env sh"
script=`mktemp`
cat > $script <<'EOF'
<<lisp-script>>

(in-package :clpp)
(include-stream *standard-input*)
EOF

: ${LISP:=sbcl}

if test $LISP = sbcl; then
  sbcl --script ${script}
elif test $LISP = ecl; then
  ecl --shell ${script}
elif test $LISP = clisp; then
  clisp ${script}
elif test $LISP = ccl; then
  ccl -b -l ${script}
elif test $LISP = gcl; then
  gcl -f ${script}
else
  echo "Error: NO LISP GIVEN"
  exit 1
fi


#+end_src

* Some examples

#+begin_src c :eval no :tangle tests/test-1.c :mkdirp t
#lisp:
(defun say-hi ()
  (print 'hi))

#include<stdio.h>

int main() {
}
#+end_src
