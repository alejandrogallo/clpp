:PROPERTIES:
:header-args:lisp: :results none :eval no
:END:
#+title: CLPP: A simple common-lisp based pre-processor
#+author: Alejandro Gallo

* Introduction

** Goals

This is the code base of a simple yet powerful
preprocessor based in the common-lisp programming language.

The goals of this project are:

- simple :: the main code should be deployed in one single
  file that is able to *run in any commonly used =CL= implementation*
  without requiring any dependency.
  This ensures that HPC clusters can use code using =CLPP=
  as a preprocessor as long as they are able to compile a =CL=
  interpreter such as =ECL=.
- lisp-based :: the macros and the language should be common lisp,
  and the macro writer should know common lisp, and only common lisp.
  We refrain from developing yet another macro language.
- configurable :: The behaviour of the preprocessor should be configurable
  in a per-project way.
- raw :: The project should not be opinionated in what respects to
  how people should embed the code in their projects and/or
  which syntax to use. It should however provide a growing list
  of examples of how to employ it.
- documentation :: The project should be well-documented and explained.
  This document represents the implementation of the code,
  and is therefore written in a literate programming style.

#+begin_comment
TODO: Think about putting this or not

Some great projects targeting some of these points but not all
are for instance

- [[https://github.com/eudoxia0/cmacro][cmacro]] ::
  The macro system is quite similar to rust syntax macros.
  - However the user has to learn the syntax of the library which
    feels quite limiting in comparison to =defmacro=.
  - Depends on several libraries.
  - Implements own parser.
- [[https://github.com/kiselgra/c-mera][c-mera]] ::
  Source-to-source translation engine.
  - Opinionated about the choice of operators to use.
  - It should be possible to use =c-mera= inside of =CLPP=.
  - c-like languages based.
#+end_comment

** Philosophy

- Use as much as possible from the common-lisp system,
  this includes the code reader and the code formatter.
- Give the user the tools to write syntax to document
  for the users of the macros.
  Provide tools and ideas, but rather than provide
  support for any programming language or system,
  which is hard to maintain and needs domain specific
  knowledge, people should write small macros to do this
  job. Therefore, most users are required to know their
  way around common lisp.

CLPP works by translating s-expressions into strings,
like any other source to source translation engine.
The rules that CLPP uses, however, as especially simple
so that one can have an easy mental map of what is coming
out after the expansion.

Any s-expression is converted to a string depending on
their type, and there the only types
pre-defined in =CLPP= are

- function-macros
- symbol-macros

#+begin_todo
Think about to give command like stuff
or let the users do it
#+end_todo

* Utilities
:PROPERTIES:
:header-args:lisp+: :noweb-ref utilities
:END:

This an implementation of a dynamic =let= for =setf=-able constructs.
#+begin_src lisp
(defmacro letf (places &rest body)
  (let ((result-v (gensym "RESULT"))
        (old-v (gensym "OLD-BINDINGS")))
    `(let ((,result-v)
           (,old-v ',(loop for p in places
                           collect `(,(car p)
                                     ,(eval (car p))))))

     ,@(loop for p in places
           collect `(setf ,(car p) ,(cadr p)))
     (setq ,result-v (progn ,@body))
     (loop for p in ,old-v
           do (eval `(setf ,(car p) ,(cadr p))))
     ,result-v)))
#+end_src

Paul Graham's =symb= function
#+begin_src lisp
(defun symb (&rest args)
  (intern (format nil "狺磲疸狎＇簌礅镬钺礤狎珞┅┅＋孱溥篁序镬镧盒蚁信以膳雍鸿遽溴颦狎珞红轶皤侯秣邂蝈痱镬镧号文＋忮玳钸篁扉箴ㄤ彐疳汶徵恒祓ê躞恒飑ㄩ瞽疳汶徵恒祓皓＋孱溥篁轴蜷徕戾盒蚁信以膳雍鸿遽溴颦狎珞红轶皤侯秣邂蝈鲠蜷徕戾号文＋忮玳钸篁扉箴ㄤ彐鲠痱弩弪鲥汜箦⑿蝈箦蝣汜箦镦翳簌礅镬蝈徜ㄤ彐鲠骢钽糸镱磲泸矬犰轶舄铋飑ㄤ彐鲠簌礅镬磲泸矬犰轶舄铋飑＋孱溥篁赠疱歪泸矬盒蚁信以膳雍鸿遽溴颦狎珞红轶皤侯秣邂蝈磲泸矬号文＋忮玳钸篁扉箴ㄤ彐躅汜颦轶狒镯ㄡ麸ㄣ狎┅ㄤ彐豉疱汜颦轶狒镯īЖ筢糸箧殄汜颦轶狒镯皓ㄤ彐躅珏舡骢钽糸镱磲泸钺礤ㄧ弭骢钽糸镱磲泸矬犰轶舄钺礤┅ㄤ彐躅骢钽糸镱磲泸锃ㄥ痱ㄧ弭骢钽糸镱磲泸ㄣ狎屮痱┅ㄤ彐豉疱骢钽糸镱磲泸īЖ犷扉篝汜颦轶狒镯筢糸箧殄骢钽糸镱磲泸锃皓┅ㄤ彐躅珏舡簌礅镬磲泸钺礤ㄧ弭簌礅镬磲泸矬犰轶舄钺礤┅ㄤ彐躅簌礅镬磲泸锃ㄥ痱ㄧ弭簌礅镬磲泸屮痱┅ㄤ彐豉疱簌礅镬磲泸īЖ犷狒镯筢糸箧殄簌礅镬磲泸锃皓┅ㄤ彐躅篝蜷铉痱彐轼痱彐轼篝颟ㄥ篝蜷铉冀痱彐轼篝颟戾铉翳痱彐轼┅ㄤ彐豉疱痱彐轼邃怡痱彐轼戾è钺礤ㄧ孱簌愆┅ㄥ鲠啜溴骢钺礤篝颟篝蜷铉痱彐轼痱彐轼ㄦ矧磲铋幄篝颟┅啜筢糸箧殄钺礤┅ㄤ彐豉疱痱彐轼邃泔眄犷痱彐轼啜犷扉篝汜颦轶狒镯筢糸箧殄痱彐轼弪皓┅ㄤ彐躅屮疳钿磲泸ㄥ痱脲蝈沲蝮轹濠ㄦ戾è屮疳钿弪ㄥㄥ疳钿磲泸候邈躜箝鲥蝈沲蝮轹濠┅ㄥ豉疱汜箦屮痱ㄦ躅泗轱瞽磲泸戾舄è钺礤ㄣ狎屮痱┅ㄡ蜱磲疸狎＇屮疳钿弪ㄣ潋屮痱┅ㄦㄧ弭骢钽糸镱磲泸钺礤┅铄鳝屮痱ㄡ痧禊狎珞┅ㄩ蝈沲蝮轹ㄥ疳钿弪铄鳝屮痱铄鳝屮痱┅簌礅镬磲泸戾舄è铄鳝钺礤ㄧ弭簌礅镬磲泸屮痱┅铄鳝钺礤┅扉篝磲疸狎＇屮疳钿弪屮痱┅屮痱┅┅＋孱溥篁涅钺黹忾钿弪＋忮玳钸篁扉箴ㄤ彐磲泸骢钽糸镱磲泸锃犰轶舡疳轵ㄡ扉篝脲狎珞扉篝矧骢瞟啜扉篝Ж珏翩犰轶К脲ㄥ豉疱汜箦扉篝矧骢ㄦ躅泗轱扉篝矧骢瞟扉篝啜灬礅溽狎珞扉篝矧骢瞟┅┅ㄤ彐磲泸簌礅镬磲泸锃犰轶舡疳轵ㄡ扉篝脲螬啜扉篝Ж珏翩犰轶К脲К螬ㄤ彐磲泸戾翥镱篝蝓泗蝈沲蝮轹疳轵泔铙趄蹉麸犰轶忾钿轭珞蝈篝怙澌戾è戾翩狎珞祜镳骘轭忾钿轭珞泔祆邈ㄥ鲠啜疳轵泔铙趄蹉麸犰轶棱┅┅啜戾翩ì漓弭姝狎珞ㄥ疳钿磲泸痱镧棱镤候邈躜箝鲥蝈沲蝮轹濠┅ㄤ彐磲泸沆痧磲泸镬弭ㄢ轭溟铉蝈篝怙澌啜戾翥镱篝蝓泗铋骢钽糸镱磲泸锃犰轶舡疳轵骢钽糸镱磲泸矬犰轶舄忾钿轭珞棱镤┅ㄤ彐磲泸沆痧簌礅镬磲泸镬弭ㄢ轭溟铉蝈篝怙澌啜戾翥镱篝蝓泗铋簌礅镬磲泸锃犰轶舡疳轵簌礅镬磲泸矬犰轶舄忾钿轭珞棱镤┅＋孱溥篁盒蚁信以膳雍鸿遽溴颦狎珞红轶皤侯秣邂蝈戾舡忾钿弪号文序彐轼弩盒蚁信以膳雍鸿遽溴颦狎珞红轶皤侯秣邂蝈痱彐轼弩号文歪轭栳钿戾蝮＋忮玳钸篁扉箴ㄤ彐鲠痱彐轼犰轶舄Жá：灬礅溽ㄩ矬痱彐轼ㄦ矧磲矬狺Β蝈徜骘蝽轶痱彐轼┅┅áｌ轶鸷灬礅溽ㄩ矬痱彐轼戾è痱弩弪鲥汜箦铋飑ㄥ鲠蝈徜骘蝽轶痱彐轼┅┅áｒ孱溴蚝灬礅溽ㄩ矬痱彐轼ㄩ瞽疳汶徵恒祓皓戾è痱弩弪鲥汜箦舂蝈钿弪蜥矬ㄥ鲠蝈徜骘蝽轶痱彐轼┅┅┅áｃ孩灬礅溽ㄩ矬痱彐轼戾è骘蝽蝈徜骘蝽轶痱彐轼┅í痱弩弪鲥汜箦舂蝈钿弪蜥矬骘蝽┅┅┅ㄤ彐磲泸磲忮蝓瞽痱彐轼ㄩ矬悌啜泔钿括祜镳骘痨轭痱彐轼犰轶舄泔祆邈啜ㄣ桢汶痱彐轼轶ㄣ狎痨┅麒孱矬ㄦ躅汜祆ㄣ潋痨轶矬ㄣ狎痨┅┅麒孱痱轭铹┅┅ㄤ彐躅汨邈氕痱彐轼轭轸痱彐轼⒚桢汶犷泔铙蹴痱彐轼殒轸磲翥桢螽涉轸滹弩铒磲翥璎轸躅蝈徜麒狒弼弪栳忮孱蝈徜祜镳骘蝈轭ㄣ镥蜚痱彐轼ъ轶舂鏖翳蝈徜汨狎铋鏖翳沲蝌孱轭轸鏖翳滹ㄩ钽椹殒ㄣ栳蚪蝈沲蝌孱舂狃疱钿麒孱ǒ戾铉翳痱彐轼┅箦翩沲蝌孱蝈徜汨狎螬瘐箬沲蝌孱蝈徜汨狎螬屐箦滹ㄤ镬轶ㄣ蝈徜汨狎螬躅蝈徜汨狎螬犷蝈趱蝾铋飑ㄤ彐躅蝈徜骘蝽痱彐轼ㄩ痱弩弪鲥汜箦戾è蝈徜翎忪濯ㄣ镳蝈徜翎忪蝈徜翎忪濯┅箦翩蝈徜翎忪瀛汜箦蝈徜翎忪濯吼蝈箦蝣濠蝈徜螬蝈徜螬┅＋孱溥篁深沆蹁＋忮玳钸篁扉箴ㄤ彐躅轭沆蹁瀛篝蝈犴镳糸镱犰篝犷溽蜾秕麴豸┅戾è屣翳瀛孱洎祜镳鏖翳铋滹箦翩蝈徜汨狎铋屣姗殒ㄥ屣姗蝈趱蝾铋屐箦滹磲忮蝓瞽痱彐轼悌┅ㄤ彐躅轭沆蹁ㄦ殪屦狒瑭鏖翳镳孱骈戾骈戾疳翳ㄩ钽祯溴篝蝈犴铋飑┅＋孱溥篁义钿弪弪盒蚁信以膳雍鸿遽溴颦狎珞红轶皤侯秣邂蝈蝈钿弪弪号文裔蝈钿弪弪＋忮玳钸篁扉箴ㄤ彐躅蝈钿弪蜥屮痱ㄥ豉疱汜箦屮痱ㄦ躅泗轱瞽磲泸戾舄è钺礤ㄣ狎屮痱┅ㄦㄧ弭骢钽糸镱磲泸钺礤┅ㄡ蜱ㄣ徜屮痱┅铄鳝屮痱ㄡ痧禊姗┅蝈钿弪蜥铄鳝屮痱┅簌礅镬磲泸蝈钿弪蜥ㄧ弭簌礅镬磲泸屮痱┅篝蜷铉ㄦ矧磲螈屮痱┅扉篝ㄦ矧磲狺" expr))
    (atom (format s "a" expr))))

#+end_src

* Library

#+begin_src lisp :tangle clpp.lisp :noweb yes :eval yes :noweb-ref lisp-script
;; vim:ft=lisp
<<prolog>>

<<utilities>>

<<variables>>

<<macros>>

<<let-binders>>

<<prefixes>>

<<renderers>>

<<cli>>

#+end_src

* CLI
:PROPERTIES:
:header-args:lisp+: :noweb-ref cli
:END:

** ecl

#+begin_src shell :noweb yes :tangle clpp :shebang "#!/usr/bin/env sh"
script=`mktemp`
cat > $script <<'EOF'
<<lisp-script>>

(in-package :clpp)
(include-stream *standard-input*)
EOF

: ${LISP:=sbcl}

if test $LISP = sbcl; then
  sbcl --script ${script}
elif test $LISP = ecl; then
  ecl --shell ${script}
elif test $LISP = clisp; then
  clisp ${script}
elif test $LISP = ccl; then
  ccl -b -l ${script}
elif test $LISP = gcl; then
  gcl -f ${script}
else
  echo "Error: NO LISP GIVEN"
  exit 1
fi


#+end_src

* Some examples

#+begin_src c :eval no :tangle tests/test-1.c :mkdirp t
#lisp:
(defun say-hi ()
  (print 'hi))

#include<stdio.h>

int main() {
}
#+end_src
